### 数据库事务

#### 什么是事务？

事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。例如，银行转账工作：从一个账号扣款并使另一个账号增款，这两个操作要么都执行，要么都不执行,在关系数据库中,一个事务可以是一条SQL语句、一组SQL语句或整个程序。 。所以，应该把它们看成一个事务。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。


#### 事务的特性

事务具体四大特性，也就是经常说的ACID 
**1. 原子性（Atomicity） **
　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。 

**2. 一致性（Consistency） **
一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。

拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务 结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。
**3. 隔离性（Isolation）**

隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
    
即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

**4. 持久性（Durability） **     持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。Mysql中会保存有相应的操作日志，即使遭遇故障依然能够通过日志恢复最后一次更新。

　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。



**四种隔离级别**

**Read Uncommitted（读取未提交内容）**

​       在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。
**Read Committed（读取提交内容）**

​        这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别  也支持所谓的不可重复读（Nonrepeatable  Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。
**Repeatable Read（可重读）**

​        这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读  （Phantom  Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影”  行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency  Control）机制解决了该问题。

**Serializable（可串行化）** 
       这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

​         这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：

​         脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。

​         不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。

​         幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。

​         在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示：

![1](./images/20190602/2.jpg)

 

**然后是关于数据库的各种锁的总结：**

1.共享锁（又称读锁）、排它锁（又称写锁）：

InnoDB引擎的锁机制：**InnoDB支持事务，支持行锁和表锁用的比较多，Myisam不支持事务，只支持表锁。**

 

共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。
意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

 

说明：

 

1）共享锁和排他锁都是行锁，意向锁都是表锁，应用中我们只会使用到共享锁和排他锁，意向锁是mysql内部使用的，不需要用户干预。**

 

2）对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁，事务可以通过以下语句显示给记录集加共享锁或排他锁。**
共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。
排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。

**对于锁定行记录后需要进行更新操作的应用，应该使用Select...For update 方式，获取排它锁。（用共享锁，在读了之后再写会阻塞，会导致死锁）

这里说说Myisam：MyISAM在执行查询语句(SELECT)前，会自动给涉及的所有表加读锁，在执行更新操作(UPDATE、DELETE、INSERT等)前，会自动给涉及的表加写锁。

 

3）InnoDB行锁是通过给索引上的索引项加锁来实现的，因此InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！**

 

2.乐观锁、悲观锁：

**悲观锁：**悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）

1）使用悲观锁，我们必须关闭mysql数据库的自动提交属性，采用手动提交事务的方式，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。

2）需要注意的是，在事务中，只有SELECT  ... FOR UPDATE 或LOCK IN SHARE MODE 同一笔数据时会等待其它事务结束后才执行，一般SELECT ...  则不受此影响。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)。

3）补充：MySQL select…for update的Row Lock与Table Lock

使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认Row-Level  Lock，所以只有「明确」地指定主键（或有索引的地方），MySQL 才会执行Row lock (只锁住被选取的数据) ，否则MySQL  将会执行Table Lock (将整个数据表单给锁住)。

**乐观锁：**

乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做（**一般是回滚事务**）。那么我们如何实现乐观锁呢，一般来说有以下2种方式：

1）.使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的  “version”  字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。

2）.乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）,   和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。

 

**总结：两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。**

　　**另外，高并发情况下个人认为乐观锁要好于悲观锁，因为悲观锁的机制使得各个线程等待时间过长，极其影响效率，乐观锁可以在一定程度上提高并发度。** 

3.表锁、行锁

 

表级锁(table-level locking)：MyISAM和MEMORY存储引擎 

行级锁(row-level locking) ：InnoDB存储引擎 

页面锁(page-level-locking)：BDB存储引擎

 

**表级锁：**开销小，加锁快;不会出现死锁;锁定粒度大，发生锁冲突的概率最高,并发度最低。 

**行级锁：**开销大，加锁慢;会出现死锁;锁定粒度最小，发生锁冲突的概率最低,并发度也最高。 

**页面锁：**开销和加锁时间界于表锁和行锁之间;会出现死锁;锁定粒度界于表锁和行锁之间，并发度一般。



### mysql有哪些数据库引擎都有什么有特点

其实，我们在日常使用的数据库中，最为常见的数据库引擎大概有四种，分别是MyISAM，InnoDB,MEMORY，以及MERGE,这四种数据库存储引擎有着各自的特点和区别，今天就和大家简单分享一下这四种存储殷勤的区别。简要区别如下：
**MyISAM:**
有存储限制，表的定义语句，数据，索引分文件存储，分别为.frm文件，.MYD（MyDate），.MYI文件（MyIndex），存储方式分静态表（默认），动态表，压缩表。静态表中表字段定长，存储速度快，容易缓存，出现故障容易恢复，但是空间浪费严重。动态表中表字段不定长，空间浪费小，但是崩溃不易恢复，频繁的删除和更新会产生大量的碎片，可以使用OPTIMIZE TABLE命令定期清理碎片。同时MyISAM存储殷勤不支持外键，也不支持事务处理，但是其优势为访问速度快，在使用中中，如果对事务完整性没有要求，或者数据库操作**主要以Select或者Insert为主**的应用基本上可以使用这种存储引擎，而且MyISAM存储殷勤在也是5.5版本之前MySQL默认的存储引擎。
**InnoDB:**
提供回滚，提交，崩溃恢复的事务安全，唯一支持外键，表中的自动增长列必须是索引，如果是组合索引，必须是组合索引的第一列，并且自动增长列支持手动插入，但是如果插入值为空或者0，则实际值为增长后的值。创建外键时，要求父表必须有对应的索引，子表在创建外键的时候，也会自动创建对应的索引。如果某个表被其他表创建了外键参照，那么该表的对应索引或者主键禁止被删除。但是在创建索引时，可以指定在对父表进行删除或者更新时，子表所对应的操作，这些操作包括以下几种：
RESTRICT,CASCADE,SET NULL,NO ACTION，其实RESTRICT和NO ACTION作用相同，是指在子表有关联记录的时候，父表不允许更新，CASCADE是指在父表执行更新或者删除操作时，更新或者删除子表对应的记录，SET NULL是指在父表执行删除或者更新操作时，子表相应字段设置为NULL。
InnoDB在存储方式上，分为共享表空间和使用多表空间存储。
**MEMORY:**
数据存储在内存中，每一个MEMORY表对应一个磁盘文件，格式为.frm。由于数据存储在内存中，所以这种索引在数据存储和数据查询方面速度最快，但是服务器停止，数据丢失。并且在索引方面默认使用HASH索引，
**MERGE:**

多个MyISAM表的集合，实际没有建立新表，而是将MyISAM集合到一起。在磁盘上保存有两个文件，一个.frm文件存储表的定义语句，另外一个是.MRG文件，包含了组合表的信息，包括MERGE表由哪些表组成，插入新的数据时的依据。如果想MERGE表中插入数据，其中MERGE表所包含的MyISAM表中都会对该数据进行存储，但是向其中一个MyISAM表插入数据时，只有当前被插入数据的MyISAM表会有相应的数据，当然MERGE表中也会有，但是另外的MyISAM表不会存储该数据。简单而言MERGE表就是多个MyISAM表的并集。 

![1](./images/20190602/1.png)

