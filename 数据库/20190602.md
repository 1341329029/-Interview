### 数据库事务

#### 什么是事务？

事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。例如，银行转账工作：从一个账号扣款并使另一个账号增款，这两个操作要么都执行，要么都不执行,在关系数据库中,一个事务可以是一条SQL语句、一组SQL语句或整个程序。 。所以，应该把它们看成一个事务。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。


#### 事务的特性

事务具体四大特性，也就是经常说的ACID 
**1. 原子性（Atomicity） **
　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。 

**2. 一致性（Consistency） **
一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。

拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务 结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。
**3. 隔离性（Isolation）**

隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
    
即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

**4. 持久性（Durability） **     持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。Mysql中会保存有相应的操作日志，即使遭遇故障依然能够通过日志恢复最后一次更新。

　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。



#### **四种隔离级别**

**Read Uncommitted（读取未提交内容）**

​       在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。
**Read Committed（读取提交内容）**

​        这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别  也支持所谓的不可重复读（Nonrepeatable  Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。
**Repeatable Read（可重读）**

​        这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读  （Phantom  Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影”  行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency  Control）机制解决了该问题。

**Serializable（可串行化）** 
       这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

​         这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：

​         脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。

​         不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。

​         幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。

​         在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示：

![1](./images/20190602/2.jpg)

 #### 并发事务带来的问题

​    相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几种情况。

- **更新丢失**（Lost  Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——最后的更新覆盖了其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改保存其更改副本的编辑人员覆盖另一个编辑人员所做的修改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题
- **脏读**（Dirty  Reads）：一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。
- **不可重复读**（Non-Repeatable Reads）：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。
- **幻读**（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。

#### **然后是关于数据库的各种锁的总结：**

1.共享锁（又称读锁）、排它锁（又称写锁）：

InnoDB引擎的锁机制：**InnoDB支持事务，支持行锁和表锁用的比较多，Myisam不支持事务，只支持表锁。**

 

共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。
意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

 

说明：

 

1）共享锁和排他锁都是行锁，意向锁都是表锁，应用中我们只会使用到共享锁和排他锁，意向锁是mysql内部使用的，不需要用户干预。**

 

2）对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁，事务可以通过以下语句显示给记录集加共享锁或排他锁。**
共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。
排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。

**对于锁定行记录后需要进行更新操作的应用，应该使用Select...For update 方式，获取排它锁。（用共享锁，在读了之后再写会阻塞，会导致死锁）

这里说说Myisam：MyISAM在执行查询语句(SELECT)前，会自动给涉及的所有表加读锁，在执行更新操作(UPDATE、DELETE、INSERT等)前，会自动给涉及的表加写锁。

 

3）InnoDB行锁是通过给索引上的索引项加锁来实现的，因此InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！**

 

#### 2.乐观锁、悲观锁：

乐观锁：每次进行数据操作时候都认为别人不会修改，所以不会上锁，但是更新时会判断别人有没有更新这个数据，适用于多读，比如write_condition。

悲观锁，每次进行数据操作时都认为别人会修改，所以每都会上锁。这样别人想拿这个数据就会Block知道他拿到锁。传统的关系型数据库就在很多地方用到这个机制，比如行锁，写锁。



3.表锁、行锁

 

表级锁(table-level locking)：MyISAM和MEMORY存储引擎 

行级锁(row-level locking) ：InnoDB存储引擎 

页面锁(page-level-locking)：BDB存储引擎

 

**表级锁：**开销小，加锁快;不会出现死锁;锁定粒度大，发生锁冲突的概率最高,并发度最低。 

**行级锁：**开销大，加锁慢;会出现死锁;锁定粒度最小，发生锁冲突的概率最低,并发度也最高。 

**页面锁：**开销和加锁时间界于表锁和行锁之间;会出现死锁;锁定粒度界于表锁和行锁之间，并发度一般。



### mysql有哪些数据库引擎都有什么有特点

其实，我们在日常使用的数据库中，最为常见的数据库引擎大概有四种，分别是MyISAM，InnoDB,MEMORY，以及MERGE,这四种数据库存储引擎有着各自的特点和区别，今天就和大家简单分享一下这四种存储殷勤的区别。简要区别如下：
**MyISAM:**
有存储限制，表的定义语句，数据，索引分文件存储，分别为.frm文件，.MYD（MyDate），.MYI文件（MyIndex），存储方式分静态表（默认），动态表，压缩表。静态表中表字段定长，存储速度快，容易缓存，出现故障容易恢复，但是空间浪费严重。动态表中表字段不定长，空间浪费小，但是崩溃不易恢复，频繁的删除和更新会产生大量的碎片，可以使用OPTIMIZE TABLE命令定期清理碎片。同时MyISAM存储殷勤不支持外键，也不支持事务处理，但是其优势为访问速度快，在使用中中，如果对事务完整性没有要求，或者数据库操作**主要以Select或者Insert为主**的应用基本上可以使用这种存储引擎，而且MyISAM存储殷勤在也是5.5版本之前MySQL默认的存储引擎。
**InnoDB:**
提供回滚，提交，崩溃恢复的事务安全，唯一支持外键，表中的自动增长列必须是索引，如果是组合索引，必须是组合索引的第一列，并且自动增长列支持手动插入，但是如果插入值为空或者0，则实际值为增长后的值。创建外键时，要求父表必须有对应的索引，子表在创建外键的时候，也会自动创建对应的索引。如果某个表被其他表创建了外键参照，那么该表的对应索引或者主键禁止被删除。但是在创建索引时，可以指定在对父表进行删除或者更新时，子表所对应的操作，这些操作包括以下几种：
RESTRICT,CASCADE,SET NULL,NO ACTION，其实RESTRICT和NO ACTION作用相同，是指在子表有关联记录的时候，父表不允许更新，CASCADE是指在父表执行更新或者删除操作时，更新或者删除子表对应的记录，SET NULL是指在父表执行删除或者更新操作时，子表相应字段设置为NULL。
InnoDB在存储方式上，分为共享表空间和使用多表空间存储。
**MEMORY:**
数据存储在内存中，每一个MEMORY表对应一个磁盘文件，格式为.frm。由于数据存储在内存中，所以这种索引在数据存储和数据查询方面速度最快，但是服务器停止，数据丢失。并且在索引方面默认使用HASH索引，
**MERGE:**

多个MyISAM表的集合，实际没有建立新表，而是将MyISAM集合到一起。在磁盘上保存有两个文件，一个.frm文件存储表的定义语句，另外一个是.MRG文件，包含了组合表的信息，包括MERGE表由哪些表组成，插入新的数据时的依据。如果想MERGE表中插入数据，其中MERGE表所包含的MyISAM表中都会对该数据进行存储，但是向其中一个MyISAM表插入数据时，只有当前被插入数据的MyISAM表会有相应的数据，当然MERGE表中也会有，但是另外的MyISAM表不会存储该数据。简单而言MERGE表就是多个MyISAM表的并集。 

![1](./images/20190602/1.png)

